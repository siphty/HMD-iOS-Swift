//
//  ADSBXResponse.swift
//  HMD
//
//  Created by Yi JIANG on 11/6/17.
//  Copyright Â© 2017 RobertYiJiang. All rights reserved.
//

// This file was generated by json2swift. https://github.com/ijoshsmith/json2swift

import Foundation

//
// MARK: - Data Model
//
struct RootType: CreatableFromJSON { // TODO: Rename this struct
    let acList: [AcList]
    let feeds: [Feeds]
    let flgH: Int
    let flgW: Int
    let lastDv: String
    let showFlg: Bool
    let showPic: Bool
    let showSil: Bool
    let shtTrlSec: Int
    let src: Int
    let srcFeed: Int
    let stm: Int
    let totalAc: Int
    init(acList: [AcList], feeds: [Feeds], flgH: Int, flgW: Int, lastDv: String, showFlg: Bool, showPic: Bool, showSil: Bool, shtTrlSec: Int, src: Int, srcFeed: Int, stm: Int, totalAc: Int) {
        self.acList = acList
        self.feeds = feeds
        self.flgH = flgH
        self.flgW = flgW
        self.lastDv = lastDv
        self.showFlg = showFlg
        self.showPic = showPic
        self.showSil = showSil
        self.shtTrlSec = shtTrlSec
        self.src = src
        self.srcFeed = srcFeed
        self.stm = stm
        self.totalAc = totalAc
    }
    init?(json: [String: Any]) {
        guard let acList = AcList.createRequiredInstances(from: json, arrayKey: "acList") else { return nil }
        guard let feeds = Feeds.createRequiredInstances(from: json, arrayKey: "feeds") else { return nil }
        guard let flgH = json["flgH"] as? Int else { return nil }
        guard let flgW = json["flgW"] as? Int else { return nil }
        guard let lastDv = json["lastDv"] as? String else { return nil }
        guard let showFlg = json["showFlg"] as? Bool else { return nil }
        guard let showPic = json["showPic"] as? Bool else { return nil }
        guard let showSil = json["showSil"] as? Bool else { return nil }
        guard let shtTrlSec = json["shtTrlSec"] as? Int else { return nil }
        guard let src = json["src"] as? Int else { return nil }
        guard let srcFeed = json["srcFeed"] as? Int else { return nil }
        guard let stm = json["stm"] as? Int else { return nil }
        guard let totalAc = json["totalAc"] as? Int else { return nil }
        self.init(acList: acList, feeds: feeds, flgH: flgH, flgW: flgW, lastDv: lastDv, showFlg: showFlg, showPic: showPic, showSil: showSil, shtTrlSec: shtTrlSec, src: src, srcFeed: srcFeed, stm: stm, totalAc: totalAc)
    }
    struct AcList: CreatableFromJSON { // TODO: Rename this struct
        let alt: Int?
        let altT: Int
        let bad: Bool
        let brng: Double
        let cMsgs: Int
        let cNum: String
        let call: String
        let callSus: Bool
        let cou: String
        let dst: Double
        let engMount: Int
        let engType: Int
        let engines: String
        let fSeen: String
        let flightsCount: Int
        let from: String?
        let gAlt: Int?
        let gnd: Bool
        let hasPic: Bool
        let hasSig: Bool
        let help: Bool
        let icao: String
        let id: Int
        let inHg: Double
        let interested: Bool
        let lat: Double
        let long: Double
        let man: String
        let mdl: String
        let mil: Bool
        let mlat: Bool
        let op: String
        let opIcao: String
        let posTime: Int
        let rcvr: Int
        let reg: String
        let spd: Double?
        let spdTyp: Int
        let species: Int
        let sqk: String
        let tSecs: Int
        let tisb: Bool
        let to: String?
        let trak: Double?
        let trkH: Bool
        let trt: Int
        let type: String
        let vsi: Int?
        let vsiT: Int
        let wTC: Int
        let year: String
        init(alt: Int?, altT: Int, bad: Bool, brng: Double, cMsgs: Int, cNum: String, call: String, callSus: Bool, cou: String, dst: Double, engMount: Int, engType: Int, engines: String, fSeen: String, flightsCount: Int, from: String?, gAlt: Int?, gnd: Bool, hasPic: Bool, hasSig: Bool, help: Bool, icao: String, id: Int, inHg: Double, interested: Bool, lat: Double, long: Double, man: String, mdl: String, mil: Bool, mlat: Bool, op: String, opIcao: String, posTime: Int, rcvr: Int, reg: String, spd: Double?, spdTyp: Int, species: Int, sqk: String, tSecs: Int, tisb: Bool, to: String?, trak: Double?, trkH: Bool, trt: Int, type: String, vsi: Int?, vsiT: Int, wTC: Int, year: String) {
            self.alt = alt
            self.altT = altT
            self.bad = bad
            self.brng = brng
            self.cMsgs = cMsgs
            self.cNum = cNum
            self.call = call
            self.callSus = callSus
            self.cou = cou
            self.dst = dst
            self.engMount = engMount
            self.engType = engType
            self.engines = engines
            self.fSeen = fSeen
            self.flightsCount = flightsCount
            self.from = from
            self.gAlt = gAlt
            self.gnd = gnd
            self.hasPic = hasPic
            self.hasSig = hasSig
            self.help = help
            self.icao = icao
            self.id = id
            self.inHg = inHg
            self.interested = interested
            self.lat = lat
            self.long = long
            self.man = man
            self.mdl = mdl
            self.mil = mil
            self.mlat = mlat
            self.op = op
            self.opIcao = opIcao
            self.posTime = posTime
            self.rcvr = rcvr
            self.reg = reg
            self.spd = spd
            self.spdTyp = spdTyp
            self.species = species
            self.sqk = sqk
            self.tSecs = tSecs
            self.tisb = tisb
            self.to = to
            self.trak = trak
            self.trkH = trkH
            self.trt = trt
            self.type = type
            self.vsi = vsi
            self.vsiT = vsiT
            self.wTC = wTC
            self.year = year
        }
        init?(json: [String: Any]) {
            guard let altT = json["AltT"] as? Int else { return nil }
            guard let bad = json["Bad"] as? Bool else { return nil }
            guard let brng = Double(json: json, key: "Brng") else { return nil }
            guard let cMsgs = json["CMsgs"] as? Int else { return nil }
            guard let cNum = json["CNum"] as? String else { return nil }
            guard let call = json["Call"] as? String else { return nil }
            guard let callSus = json["CallSus"] as? Bool else { return nil }
            guard let cou = json["Cou"] as? String else { return nil }
            guard let dst = Double(json: json, key: "Dst") else { return nil }
            guard let engMount = json["EngMount"] as? Int else { return nil }
            guard let engType = json["EngType"] as? Int else { return nil }
            guard let engines = json["Engines"] as? String else { return nil }
            guard let fSeen = json["FSeen"] as? String else { return nil }
            guard let flightsCount = json["FlightsCount"] as? Int else { return nil }
            guard let gnd = json["Gnd"] as? Bool else { return nil }
            guard let hasPic = json["HasPic"] as? Bool else { return nil }
            guard let hasSig = json["HasSig"] as? Bool else { return nil }
            guard let help = json["Help"] as? Bool else { return nil }
            guard let icao = json["Icao"] as? String else { return nil }
            guard let id = json["Id"] as? Int else { return nil }
            guard let inHg = Double(json: json, key: "InHg") else { return nil }
            guard let interested = json["Interested"] as? Bool else { return nil }
            guard let lat = Double(json: json, key: "Lat") else { return nil }
            guard let long = Double(json: json, key: "Long") else { return nil }
            guard let man = json["Man"] as? String else { return nil }
            guard let mdl = json["Mdl"] as? String else { return nil }
            guard let mil = json["Mil"] as? Bool else { return nil }
            guard let mlat = json["Mlat"] as? Bool else { return nil }
            guard let op = json["Op"] as? String else { return nil }
            guard let opIcao = json["OpIcao"] as? String else { return nil }
            guard let posTime = json["PosTime"] as? Int else { return nil }
            guard let rcvr = json["Rcvr"] as? Int else { return nil }
            guard let reg = json["Reg"] as? String else { return nil }
            guard let spdTyp = json["SpdTyp"] as? Int else { return nil }
            guard let species = json["Species"] as? Int else { return nil }
            guard let sqk = json["Sqk"] as? String else { return nil }
            guard let tSecs = json["TSecs"] as? Int else { return nil }
            guard let tisb = json["Tisb"] as? Bool else { return nil }
            guard let trkH = json["TrkH"] as? Bool else { return nil }
            guard let trt = json["Trt"] as? Int else { return nil }
            guard let type = json["Type"] as? String else { return nil }
            guard let vsiT = json["VsiT"] as? Int else { return nil }
            guard let wTC = json["WTC"] as? Int else { return nil }
            guard let year = json["Year"] as? String else { return nil }
            let alt = json["Alt"] as? Int
            let from = json["From"] as? String
            let gAlt = json["GAlt"] as? Int
            let spd = Double(json: json, key: "Spd")
            let to = json["To"] as? String
            let trak = Double(json: json, key: "Trak")
            let vsi = json["Vsi"] as? Int
            self.init(alt: alt, altT: altT, bad: bad, brng: brng, cMsgs: cMsgs, cNum: cNum, call: call, callSus: callSus, cou: cou, dst: dst, engMount: engMount, engType: engType, engines: engines, fSeen: fSeen, flightsCount: flightsCount, from: from, gAlt: gAlt, gnd: gnd, hasPic: hasPic, hasSig: hasSig, help: help, icao: icao, id: id, inHg: inHg, interested: interested, lat: lat, long: long, man: man, mdl: mdl, mil: mil, mlat: mlat, op: op, opIcao: opIcao, posTime: posTime, rcvr: rcvr, reg: reg, spd: spd, spdTyp: spdTyp, species: species, sqk: sqk, tSecs: tSecs, tisb: tisb, to: to, trak: trak, trkH: trkH, trt: trt, type: type, vsi: vsi, vsiT: vsiT, wTC: wTC, year: year)
        }
    }
    struct Feeds: CreatableFromJSON { // TODO: Rename this struct
        let id: Int
        let name: String
        let polarPlot: Bool
        init(id: Int, name: String, polarPlot: Bool) {
            self.id = id
            self.name = name
            self.polarPlot = polarPlot
        }
        init?(json: [String: Any]) {
            guard let id = json["id"] as? Int else { return nil }
            guard let name = json["name"] as? String else { return nil }
            guard let polarPlot = json["polarPlot"] as? Bool else { return nil }
            self.init(id: id, name: name, polarPlot: polarPlot)
        }
    }
}

//
// MARK: - JSON Utilities
//
/// Adopted by a type that can be instantiated from JSON data.
protocol CreatableFromJSON {
    /// Attempts to configure a new instance of the conforming type with values from a JSON dictionary.
    init?(json: [String: Any])
}

extension CreatableFromJSON {
    /// Attempts to configure a new instance using a JSON dictionary selected by the `key` argument.
    init?(json: [String: Any], key: String) {
        guard let jsonDictionary = json[key] as? [String: Any] else { return nil }
        self.init(json: jsonDictionary)
    }
    
    /// Attempts to produce an array of instances of the conforming type based on an array in the JSON dictionary.
    /// - Returns: `nil` if the JSON array is missing or if there is an invalid/null element in the JSON array.
    static func createRequiredInstances(from json: [String: Any], arrayKey: String) -> [Self]? {
        guard let jsonDictionaries = json[arrayKey] as? [[String: Any]] else { return nil }
        return createRequiredInstances(from: jsonDictionaries)
    }
    
    /// Attempts to produce an array of instances of the conforming type based on an array of JSON dictionaries.
    /// - Returns: `nil` if there is an invalid/null element in the JSON array.
    static func createRequiredInstances(from jsonDictionaries: [[String: Any]]) -> [Self]? {
        var array = [Self]()
        for jsonDictionary in jsonDictionaries {
            guard let instance = Self.init(json: jsonDictionary) else { return nil }
            array.append(instance)
        }
        return array
    }
    
    /// Attempts to produce an array of instances of the conforming type, or `nil`, based on an array in the JSON dictionary.
    /// - Returns: `nil` if the JSON array is missing, or an array with `nil` for each invalid/null element in the JSON array.
    static func createOptionalInstances(from json: [String: Any], arrayKey: String) -> [Self?]? {
        guard let array = json[arrayKey] as? [Any] else { return nil }
        return createOptionalInstances(from: array)
    }
    
    /// Attempts to produce an array of instances of the conforming type, or `nil`, based on an array.
    /// - Returns: An array of instances of the conforming type and `nil` for each invalid/null element in the source array.
    static func createOptionalInstances(from array: [Any]) -> [Self?] {
        return array.map { item in
            if let jsonDictionary = item as? [String: Any] {
                return Self.init(json: jsonDictionary)
            }
            else {
                return nil
            }
        }
    }
}

extension Date {
    // Date formatters are cached because they are expensive to create. All cache access is performed on a serial queue.
    private static let cacheQueue = DispatchQueue(label: "DateFormatterCacheQueue")
    private static var formatterCache = [String: DateFormatter]()
    private static func dateFormatter(with format: String) -> DateFormatter {
        if let formatter = formatterCache[format] { return formatter }
        let formatter = DateFormatter()
        formatter.dateFormat = format
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.calendar = Calendar(identifier: .gregorian)
        formatter.timeZone = TimeZone(secondsFromGMT: 0)! // UTC is assumed, but won't interfere with a format-specified time zone.
        formatterCache[format] = formatter
        return formatter
    }
    
    static func parse(string: String, format: String) -> Date? {
        var formatter: DateFormatter!
        cacheQueue.sync { formatter = dateFormatter(with: format) }
        return formatter.date(from: string)
    }
    
    init?(json: [String: Any], key: String, format: String) {
        guard let string = json[key] as? String else { return nil }
        guard let date = Date.parse(string: string, format: format) else { return nil }
        self.init(timeIntervalSinceReferenceDate: date.timeIntervalSinceReferenceDate)
    }
}

extension URL {
    init?(json: [String: Any], key: String) {
        guard let string = json[key] as? String else { return nil }
        self.init(string: string)
    }
}

extension Double {
    init?(json: [String: Any], key: String) {
        // Explicitly unboxing the number allows an integer to be converted to a double,
        // which is needed when a JSON attribute value can have either representation.
        guard let nsNumber = json[key] as? NSNumber else { return nil }
        self.init(_: nsNumber.doubleValue)
    }
}

extension Array where Element: NSNumber {
    // Convert integers to doubles, for example [1, 2.0] becomes [1.0, 2.0]
    // This is necessary because ([1, 2.0] as? [Double]) yields nil.
    func toDoubleArray() -> [Double] {
        return map { $0.doubleValue }
    }
}

extension Array where Element: CustomStringConvertible {
    func toDateArray(withFormat format: String) -> [Date]? {
        var dateArray = [Date]()
        for string in self {
            guard let date = Date.parse(string: String(describing: string), format: format) else { return nil }
            dateArray.append(date)
        }
        return dateArray
    }
    
    func toURLArray() -> [URL]? {
        var urlArray = [URL]()
        for string in self {
            guard let url = URL(string: String(describing: string)) else { return nil }
            urlArray.append(url)
        }
        return urlArray
    }
}

extension Array where Element: Any {
    func toOptionalValueArray<Value>() -> [Value?] {
        return map { ($0 is NSNull) ? nil : ($0 as? Value) }
    }
    
    func toOptionalDateArray(withFormat format: String) -> [Date?] {
        return map { item in
            guard let string = item as? String else { return nil }
            return Date.parse(string: string, format: format)
        }
    }
    
    func toOptionalDoubleArray() -> [Double?] {
        return map { item in
            guard let nsNumber = item as? NSNumber else { return nil }
            return nsNumber.doubleValue
        }
    }
    
    func toOptionalURLArray() -> [URL?] {
        return map { item in
            guard let string = item as? String else { return nil }
            return URL(string: string)
        }
    }
}
